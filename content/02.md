#第2章 构造函数语意学（The Semantics of Constructors）

- **implicit**：暗中的、隐含的（通常意指并非在程序源代码中出现的）
- **explicit**：明确的（通常意指程序源代码中所出现的）
- **trivial**：没有用的
- **nontrivial**：有用的
- **memberwise**：对每一个member施以
- **bitwise**：对每一个bit施以

##Default Constructor的建构操作
> 对于class X，如果没有任何user-declared constructor，那么会有一个default constructor被暗中（implicitly）声明出来……一个被暗中声明出来的default constructor将是一个trivial（浅薄而无能，没啥用的）constructor……

下面分别讨论nontrivial default constructor的四种情况：

###“带有Default Constructor”的Member Class Object
如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么这个class的implicit default constructor就是“nontrivial”，编译器需要为此class合成出一个default constructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。

在C++各个不同的编译器模块中，编译器如何避免合成出多个default constructor呢？解决方法是把合成的default constructor、copy constructor、destructor、assignment copy operator都以inline方式完成。一个inline函数有静态链接，不会被档案以外者看到。如果函数太复杂，不适合做成inline，就会合成出一个explicit non-inline static实体。

举个例子，在下面的程序片段中，编译器为class Bar合成一个default constructor：

```C++
class Foo { public: Foo(), Foo(int) ... };
class Bar { public: Foo foo; char *str; };

void foo_bar()
{
	Bar bar; // Bar::foo 必须在此处初始化
             // Bar::foo是一个member object，而其class Foo
			 // 拥有default constructor

	if (str) {} ...
}
```

被合成的Bar default constructor内含必要的代码，能够调用class Foo的default constructor来处理member object Bar::foo，但它并不产生任何买代码来初始化Bar::str。是的，将Bar::foo初始化是编译器的责任，将Bar::str初始化则是程序员的责任。被合成的default constructor看起来可能像这样：

```C++
inline
Bar::Bar()
{
	foo.Foo::Foo();
}
```

为了让这个程序片段能够正确执行，字符指针str也需要被初始化。让我们假设程序员经由下面的default constructor提供了str的初始化操作：

```C++
Bar::Bar() { str = 0; }
```

现在程序的需求获得满足了，但是编译器还需要初始化member object foo。由于default constructor已经被明确地定义出来，编译器没办法合成第二个。编译器的行动是“如果class A内含一个或一个以上的member class objects，那么class A的每一个constructor必须调用每一个member class的default constructor”。编译器会扩展已存在的constructors，在其中安插一些代码，使得user coode在被执行之前，先调用必要的default constructors。

```C++
Bar::Bar()
{
	foo.Foo::Foo();
	str = 0;
}
```

如果有多个class member objects都要求constructor初始化操作，将如何呢？C++语言要求以“member objects在class中的声明次序”来调用各个constructors。这一点由编译器完成，它为每一个constructor安插程序代码，以“member声明次序”调用每一个member所关联的default constructors。这些代码将被安插在explicit user code之前。

###“带有Default Constructor”的Base Class
如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层base classes的default constructor（根据它们的声明次序）。对一个后继派生的class而言，这个合成的constructor和一个“被明确提供的default constructor”没有什么差异。

###“带有一个Virtual Function”的Class
- class声明（或继承）一个virtual function
- class派生自一个继承串链，其中有一个或更多的virtual base classes

```C++
class Wdiget {
public:
	virtual void flip() = 0;
};

void flip(const Widget& widget) { widget.flip(); }

// 假设Bell和Whistle都派生自Widget
void foo()
{
	Bell b;
	Whistle w;

	flip(b);
	flip(w);
}
```

下面两个扩张操作会在编译期间发生：

1. 一个virtual function table（在cfront中被称为vtbl）会被编译器产生出来，内放class的virtual functions地址。
2. 在每一个class object中，一个额外的pointer member（也就是vptr）会被编译器合成出来，内含相关的class vtbl的地址。 

此外，`widget.flip()`的虚拟引发操作会被重新改写，以使用widget的vptr和vtbl的`flip()`条目：

```C++
// widget.flip()的虚拟引发操作的转变
(*widget.vptr[1])(&widget)
```

为了让这个机制发挥功效，编译器必须为每一个Widget（或其派生类之）object的vptr设定初值，放置适当的virtual table地址。对于class所定义的每一个constructor，编译器会安插一些代码来做这些事情。对于那些未声明任何constructors的classes，编译器会为它们合成一个default constructor，以便正确地初始化每一个class object的vptr。

###“带有一个Virtual Base Class”的Class
Virtual base class的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共通点在于必须使virtual base class在其每一个derived class object中的位置，能够于执行期准备妥当。

```C++
class X { public: int i; };
class A : public virtual X { public: int j; };
class B : public virtual X { public: double d; };
class C : public A, public B { public: int k; };

// 无法在编译时期决定出pa->X::i的位置
void foo(const A* pa) { pa->i = 1024; }

main()
{
	foo(new A);
	foo(new C);
	// ...
}
```

编译器无法固定住foo()之中“经由pa而存取的X::i”的实际偏移位置，因为pa的真正类型可以改变，编译器必须改变“执行存取操作”的那些代码，使X::i可以延迟至执行期才决定下来。原先cfront的做法是靠“在derived class object的每一个virtual base classes中安插一个指针”完成。所有“经由reference或pointer来存取一个virtual base class”的操作都可以通过相关指针完成。

```C++
// 可能的编译器转变操作
void foo(const A* pa) { pa->__vbcX->i = 1024; }
```

其中`__vbcX`表示编译器所产生的指针，指向virtual base class X。`__vbcX`是在class object建构期间被完成的。对于class所定义的每一个constructor，编译器会安插那些“允许每一个virtual base class的执行期存取操作”的代码。如果class没有声明任何constructors，编译器必须为它合成一个default constructor。

###总结
有四种情况，会导致“编译器必须为未声明constructor之classes合成一个default constructor”。C++ Standard把那些合成物称为implicit nontrivial default constructors。被合成出来的constructor只能满足编译器的需要。它之所以能够完成任务，是借着“调用member object或base class的default constructor”或是“为每一个初始化其virtual function机制或virtual base class机制”而完成。至于没有存在那四种情况而又没有声明任何constructor的classes，我们说它们拥有的是implicit trivial default constructors，它们实际上并不会被合成出来。

在合成的default constructor中，只有base class subobjects和member class objects会被初始化。所有其它的nonstatic data member，如整数、整数指针、整数数组等等都不会被初始化。如果程序需要一个“把某指针设为0”的default constructor，那么提供它的人应该是程序员。

##Copy Constructor的建构操作