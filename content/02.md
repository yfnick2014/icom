#第2章 构造函数语意学（The Semantics of Constructors）

- **implicit**：暗中的、隐含的（通常意指并非在程序源代码中出现的）
- **explicit**：明确的（通常意指程序源代码中所出现的）
- **trivial**：没有用的
- **nontrivial**：有用的
- **memberwise**：对每一个member施以
- **bitwise**：对每一个bit施以

##Default Constructor的建构操作
> 对于class X，如果没有任何user-declared constructor，那么会有一个default constructor被暗中（implicitly）声明出来……一个被暗中声明出来的default constructor将是一个trivial（浅薄而无能，没啥用的）constructor……

下面分别讨论nontrivial default constructor的四种情况：

###“带有Default Constructor”的Member Class Object
如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么这个class的implicit default constructor就是“nontrivial”，编译器需要为此class合成出一个default constructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。

在C++各个不同的编译器模块中，编译器如何避免合成出多个default constructor呢？解决方法是把合成的default constructor、copy constructor、destructor、assignment copy operator都以inline方式完成。一个inline函数有静态链接，不会被档案以外者看到。如果函数太复杂，不适合做成inline，就会合成出一个explicit non-inline static实体。

举个例子，在下面的程序片段中，编译器为class Bar合成一个default constructor：

```C++
class Foo { public: Foo(), Foo(int) ... };
class Bar { public: Foo foo; char *str; };

void foo_bar()
{
	Bar bar; // Bar::foo 必须在此处初始化
             // Bar::foo是一个member object，而其class Foo
			 // 拥有default constructor

	if (str) {} ...
}
```

被合成的Bar default constructor内含必要的代码，能够调用class Foo的default constructor来处理member object Bar::foo，但它并不产生任何买代码来初始化Bar::str。是的，将Bar::foo初始化是编译器的责任，将Bar::str初始化则是程序员的责任。被合成的default constructor看起来可能像这样：

```C++
inline
Bar::Bar()
{
	foo.Foo::Foo();
}
```

为了让这个程序片段能够正确执行，字符指针str也需要被初始化。让我们假设程序员经由下面的default constructor提供了str的初始化操作：

```C++
Bar::Bar() { str = 0; }
```

现在程序的需求获得满足了，但是编译器还需要初始化member object foo。由于default constructor已经被明确地定义出来，编译器没办法合成第二个。编译器的行动是“如果class A内含一个或一个以上的member class objects，那么class A的每一个constructor必须调用每一个member class的default constructor”。编译器会扩展已存在的constructors，在其中安插一些代码，使得user coode在被执行之前，先调用必要的default constructors。

```C++
Bar::Bar()
{
	foo.Foo::Foo();
	str = 0;
}
```

如果有多个class member objects都要求constructor初始化操作，将如何呢？C++语言要求以“member objects在class中的声明次序”来调用各个constructors。这一点由编译器完成，它为每一个constructor安插程序代码，以“member声明次序”调用每一个member所关联的default constructors。这些代码将被安插在explicit user code之前。

###“带有Default Constructor”的Base Class
如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层base classes的default constructor（根据它们的声明次序）。对一个后继派生的class而言，这个合成的constructor和一个“被明确提供的default constructor”没有什么差异。

###“带有一个Virtual Function”的Class
