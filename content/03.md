#Data语意学（The Semantics of Data）
```C++
class X {};
class Y : public virtual X {};
class Z : public virtual X {};
class A : public Y, public Z {};

// Intel Xeon x64, g++ version 4.9.2
// sizeof(X) = 1
// sizeof(Y) = sizeof(Z) = 8
// sizeof(A) = 16
```

`sizeof(X) = 1`表明X并不是空的，它有一个隐晦的1byte，那是被编译器安插进去的一个char。这使得这个class的两个objects得以在内存中配置独一无二的地址。

事实上Y和Z的大小受到三个因素的影响：

1. **语言本身所造成的额外负担（overhead）**。当语言支持virtual base classes时，就会导致一些额外负担。在derived class中，这个额外负担反映在某种形式的指针身上，它或者指向virtual base class subobject，或者指向一个相关表格；表格中存放的若不是virtual base class subobject的地址，就是其偏移量。
2. **编译器对于特殊情况所提供的优化处理**。Virtual base class X subobject的1 byte大小也会出现在class Y和Z身上。传统上它会被放在derived class的固定（不变动）部分的尾端。某些编译器会对empty virtual base class提供特殊支持。
3. **Alignment的限制**。alignment就是将数值调整到某数的整数倍。在32位计算机上，通常alignment为4bytes（32位），以使bus的“运输量”达到最高效率。

![](../images/03.01.png)

Empty virtual base class已经成为C++ OO设计的一个特有术语了。它提供了一个virtual interface，没有定义任何数据。某些新近的编译器对此提供了特殊处理。在这个策略之下，一个empty virtual base class被视为derived class object最开头的一部分，也就是它并没有花费任何的额外空间。

![](../images/03.02.png)

记住，一个virtual base class subobject只会在derived class中存在一份实体，不管它在class继承体系中出现了多少次。class A的大小由以下几点决定：

- 被大家共享的唯一一个class X实体，大小为1byte。
- Base class Y的大小，减去“因virtual base X而配置”的大小，结果是4bytes。Base class Z的算法亦同。加起来是8bytes。
- class A自己的大小：0byte。
- class A的alignment数量。前述三项总和，表示调整前的大小是9bytes。class A必须调整至4 bytes边界，所以需要填补3 bytes。结果是12bytes。

C++ Standard并不强制规定如“base class subobjects的排序次序”或“不同存取层级的data members的排列次序”这种琐碎细节。它也不规定virtual functions或virtual base classes的实现细节。

C++对象模型尽量以空间优化和存取速度优化的考虑来表现nonstatic data members，并且保持和C语言struct数据配置的兼容性。它把数据直接存放在每一个class object之中。对于继承而来的nonstatic data members（不管是virtual或nonvirtual base class）也是如此。不过并没有强制定义其间的排列顺序。至于static data members，则被放置在程序的一个global data segment中，不会影响个别的class object的大小。在程序之中，不管该class被产生出多少个objects（经由产生或间接派生），static data members永远只存在一份实体。但是一个template class的static data members的行为稍有不同。

每一个class object因此必须有足够的大小以容纳它所有的nonstatic data members。有时候其值可能令你吃惊，因为它可能比你想象的还大，原因是：

1. 由编译器自动加上的额外data members，用以支持某些语言特性（主要是各种virtual特性）。
2. 因为alignment的需要。

##3.1 Data Member的绑定（The Binding of a Data Member）
member rewriting rlue：一个inline函数实体，在整个class声明未被完全看见之前，是不会被评估请求的。其效果是，如果一个inline函数在class声明之后被定义的话，那么就还是对其评估求值。然而，对于member function的argument list并不为真。Argument list中的名称还是会在它们第一次遭遇时被适当地决议完成。请始终把“nested type声明”放在class的起始处。

```C++
extern int x;

class Pint3d {
public:
	// 对于函数本身的分析将延迟直至
	// class声明的右大括号出现才开始
	float X() const { return x; }
private:
	float x;
};

typedef int length;

class Point3d {
public:
	// length被决议为global
	void mumble(length val) { _val = val; }
	length mumble() { return _val; }

private:
	// length必须在“本class对它的第一个参考操作”之前被看见
	// 这样的声明将使先前的参考操作不合法
	typedef float length;
	length _val;
};
```

##3.2 Data Member的布局（Data Member Layout）
C++ Standard要求，在同一个access section（也就是private、public、protected等区段）中，members的排列只需符合“较晚出现的members在class object中有较高的地址”这一条件即可。也就是说，各个members并不一定得连续排列。members的边界调整可能就需要填补一些bytes。

编译器还可能会合成一些内部使用的data members，以支持整个对象模型，vptr就是这样的东西，当前所有的编译器都把它安插在每一个“内含virtual function之class”的object内。vptr的位置传统上它会被放在所有明确声明的members的最后。不过如今也有一些编译器把vptr放在一个class object的最前端。C++ standard秉持“对于布局所持的放任态度”，允许编译器把那些内部产生出来的members自由放在任何位置上，甚至放在那些被程序员声明出来的members之间。

##3.3 Data Member的存取
###Static Data Members
Static data members被编译器提出于class之外，并被视为一个global变量。每一个member的存取许可（private、protected或public），以及与class的关联，并不会导致任何空间上或执行时间上的额外负担——不论是在个别的class objects或是在static data member本身。

每一个static data member只有一个实体，存放在程序的data segment之中。每次程序取用static member，就会被内部转化为对该唯一的extern实体的直接参考操作。

如果有两个class，每一个都声明了一个static member freeList，那么当它们都被放在程序的data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个static data member编码（name-mangling），以获得一个独一无二的程序识别代码。任何name-mangling做法都有两个要点：

1. 一种算法，推导出独一无二的名称。
2. 万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。

###Nonstatic Data Members
