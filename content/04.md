#Function语意学（The Semantics of Function）
##4.1 Member的各种调用方式
>有一种常见的观点，认为virtual functions只不过是一种跛脚的函数指针，没什么用……其意思主要就是，virtual functions是一种没有效能的形式。

###Nonstatic Member Functions（非静态成员函数）
C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmember function有相同的效率。也就是说，如果我们要在以下两个函数之间做选择：

```C++
float magnitude3d(const Point3d *_this) { ... }
float Point3d::magnitude3d() const { ... }
```

那么选择member function不应该带来什么额外负担。这是因为编译器内部已将“member函数实体”转换为对等的“nonmember函数实体”。

```C++
float
Point3d::magnitude3d() const
{
	return sqrt(_x * _x + _y * _y + _z * _z);
}

float magnitude3d(const Point3d *_this) {
	return sqrt(_this->_x * _this->_x +
				_this->_y * _this->_y +
				_this->_z * _this->_z);
}
```

乍见之下似乎nonmember function比较没有效率，它间接地经由参数取用坐标成员，而member function却是直接取用坐标成员。然而实际上member function被内化为nonmember的形式。下面就是转化步骤：

（1）改写函数的signature以安插一个额外的参数到member function中，用以提供一个存取管道，使class object得以调用该函数。该额外参数被称为this指针：

```C++
// non-const nonstatic member之增长过程
Point3d
Point3d::magnitude(Point3d *const this)
```

如果member function是const，则变成：

```C++
// const nonstatic member之扩张过程
Point3d
Point3d::magnitude(const Point3d * const this)
```

（2）将每一个“对nonstatic data member的存取操作”改为经由this指针来存取：

```C++
{
	return sqrt(
		this->_x * this->_x +
		this->_y * this->_y +
		this->_z * this->_z);
}
```

（3）将member function重写成为一个外部函数，对函数名称进行mangling处理，使它在程序中成为独一无二的语汇：

```C++
extern magnitude__7Point3dFv(
	register Point3d *const this);
```

现在这个函数已经被转换好了，而其每一个调用操作也都必须转换。于是：

```C++
obj.magnitude();

===>
magnitude__7Point3dFv(&obj);

ptr->magnitude();

===>
magnitude__7Point3dFv(ptr);
```

normalized()函数定义如下，其中假设已经声明有一个Point3d copy constructor，而named returned value的优化也已施行：

```C++
Point3d
Point3d::normalize() const
{
	register float mag = magnitude();
	Point3d normal;

	normal._x = _x/mag;
	normal._y = _y/mag;
	normal._z = _z/mag;

	return normal;
}

// 以下描述named return value函数的内部转化
void
normalize__7Point3dFv(register const Point3d *const this,
						Point3d &__result)
{
	register float mag = this->magnitude();

	// default constructor
	__result.Point3d::Point3d();

	__result._x = this->_x/mag;
	__result._y = this->_y/mag;
	__result._z = this->_z/mag;

	return;
}
```

一个比较有效率的做法是直接建构normal值，像这样：

```C++
Point3d
Point3d::normalize() const
{
	register float mag = magnitude();
	return Point3d(_x/mag, _y/mag, _z/mag);
}

//内部转化，这可以节省default constructor初始化所引起的额外负担
void
normalize__7Point3dFv(register const Point3d *const this,
						Point3d &__result)
{
	register float mag = this->magnitude();

	// __result用以取代返回值
	__result.Point3d::Point3d(this->_x/mag, this->_y/mag, this->_z/mag);

	return;
}
```

####名称的特殊处理（Name Mangling）
一般而言，member的名称前面会被加上class名称，形成独一无二的命名。例如下面的声明：

```C++
class Bar { public: int ival; ... };
```

其中的ival有可能变成这样：

```C++
// member经过name-mangling之后的可能结果之一
ival__3Bar
```

为什么编译器要这么做？请考虑这样的派生操作（derivation）：

```C++
class Foo : public Bar { public: int ival; ... };
```

记住，Foo对象内部结合了base class和derived class两者：

```C++
// C++伪代码
// Foo的内部描述
class Foo {
public:
	int ival__3Bar;
	int ival__3Foo;
};
```

不管你要处理哪一个ival，通过“name mangling”，都可以绝对清楚地指出来。由于member functions可以被重载化（overloaded），所以需要更广泛的mangling手法，已提供绝对独一无二的名称。如果把：

```C++
class Point {
public:
	void x(float newX);
	float x();
	...
};
```

转换为：

```C++
class Point {
public:
	void x__5Point(float newX);
	float x__5Point();
};
```

会导致两个被重载化（overloaded）的函数实体拥有相同的名称。为了让它们独一无二，唯有再加上它们的参数链表（可以从函数原型中参考得到）。如果把参数类型也编码进去，就一定可以制造出独一无二的结果，使我们的两个x()函数有良好的转换（但如果你声明extern "C"，就会压抑nonmember functions的“mangling”效果）：

```C++
class Point {
public:
	void x__5PointFf(float newX);
	float x__5PointFv();
};
```

把参数和函数名称编码在一起，编译器于是在不同的被编译模块之间达成了一种有限形式的类型检验。举个例子，如果一个print函数被这样定义：

```C++
void print(const Point3d&) { ... }
```

但意外地被这样声明和调用：

```C++
void print(const Point3d);
```

两个实体如果拥有独一无二的name mangling，那么任何不正确的调用操作在链接时期就因无法决议而失败。有时候我们可以乐观地称此为“确保类型安全的链接行为”。我说“乐观地”是因为它只可以捕捉函数的标记（亦即函数名称+参数数目+参数类型）错误：如果“返回类型”声明错误，就没办法检查出来！

当前的编译系统中，有一种所谓的demangling工具，用来拦截名称并将其转换回去。使用者可以仍然处于“不知道内部名称”的极大幸福之中。然而生命并不是长久以来一直如此轻松，在cfront 1.1版，由于该系统未经世故，故总是收藏两种名称；编译错误消息用的是程序代码行数名称，然而链接器却不，它用的是经过mangled的内部名称。

###Virtual Member Functions（虚拟成员函数）
